import { createClient } from '@supabase/supabase-js';

// Fallback interface for development/offline
export interface ReconResult {
  lastScan: string;
  totalLinks: number;
  status: string;
  recoveredArticles: Array<{
    url: string;
    title: string;
    source: string;
  }>;
}

// Environment variables should be in .env.local
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || '';
const SUPABASE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || '';

// Create Supabase client only if keys exist
export const supabase = SUPABASE_URL && SUPABASE_KEY 
  ? createClient(SUPABASE_URL, SUPABASE_KEY)
  : null;

// Service to fetch data (Hybrid: Supabase -> JSON Fallback)
export const ReconService = {
  async getLatestResults(): Promise<ReconResult> {
    try {
      // 1. Try Supabase first (if configured)
      if (supabase) {
        const { data, error } = await supabase
          .from('recon_scans')
          .select('*')
          .order('created_at', { ascending: false })
          .limit(1)
          .single();

        if (data && !error) {
          return {
            lastScan: data.created_at,
            totalLinks: data.total_links,
            status: data.status,
            recoveredArticles: data.results_json // Assuming JSONB column
          };
        }
      }

      // 2. Fallback to Local JSON (Generated by GitHub Actions)
      console.log('Supabase not connected or empty. Fetching local JSON...');
      const response = await fetch('/data/recon_results.json?t=' + Date.now());
      if (!response.ok) throw new Error('Local JSON not found');
      return await response.json();

    } catch (error) {
      console.error('Recon Service Error:', error);
      // 3. Ultimate Fallback (Empty State)
      return {
        lastScan: new Date().toISOString(),
        totalLinks: 0,
        status: 'Offline / Error',
        recoveredArticles: []
      };
    }
  }
};
