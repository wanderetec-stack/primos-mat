import { createClient } from '@supabase/supabase-js';

// Fallback interface for development/offline
export interface ReconResult {
  lastScan: string;
  totalLinks: number;
  status: string;
  recoveredArticles: Array<{
    url: string;
    title: string;
    source: string;
  }>;
}

// Environment variables should be in .env.local
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || '';
const SUPABASE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || '';

// Create Supabase client only if keys exist
export const supabase = SUPABASE_URL && SUPABASE_KEY 
  ? createClient(SUPABASE_URL, SUPABASE_KEY)
  : null;

// Service to fetch data (Hybrid: Supabase -> JSON Fallback)
export const ReconService = {
  async getLatestResults(): Promise<ReconResult> {
    // 1. Try Supabase first (if configured)
    if (supabase) {
      try {
        const { data, error } = await supabase
          .from('recon_scans')
          .select('*')
          .order('created_at', { ascending: false })
          .limit(1)
          .single();

        let detailedArticles: any[] = [];
        
        // Fetch detailed items from scanned_urls (The Archaeologist's Findings)
        const { data: scanItems } = await supabase
          .from('scanned_urls')
          .select('*')
          .eq('status', 'recuperado') // Only show successful recoveries
          .order('created_at', { ascending: false })
          .limit(20);

        if (scanItems) {
            detailedArticles = scanItems.map(item => ({
                url: item.url,
                title: item.title,
                source: item.source
            }));
        }

        if (data && !error) {
          return {
            lastScan: data.created_at,
            totalLinks: data.total_links,
            status: data.status,
            // Prioritize Real DB findings over the summary JSON if available
            recoveredArticles: detailedArticles.length > 0 ? detailedArticles : data.results_json
          };
        }
        console.warn('Supabase returned error or no data, falling back to JSON:', error);
      } catch (err) {
        console.warn('Supabase connection failed, falling back to JSON:', err);
      }
    }

    // 2. Fallback to Local JSON (Generated by GitHub Actions)
    try {
      console.log('Fetching local JSON...');
      const response = await fetch('/data/recon_results.json?t=' + Date.now());
      if (!response.ok) throw new Error('Local JSON not found');
      return await response.json();
    } catch (error) {
      console.error('Recon Service Error (JSON):', error);
      // 3. Ultimate Fallback (Empty State)
      return {
        lastScan: new Date().toISOString(),
        totalLinks: 0,
        status: 'Offline / Error',
        recoveredArticles: []
      };
    }
  }
};
