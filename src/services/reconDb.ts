import { createClient } from '@supabase/supabase-js';

export interface RecoveredArticle {
  url: string;
  title: string;
  source: string;
}

export interface DraftArticle {
  id: string;
  original_url: string;
  title: string;
  status: string;
  created_at: string;
}

export interface ReconResult {
  lastScan: string;
  totalLinks: number;
  status: string;
  recoveredArticles: RecoveredArticle[];
  drafts: DraftArticle[];
}

interface ScannedUrl {
  url: string;
  title: string;
  source: string;
}

// Environment variables should be in .env.local
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || '';
const SUPABASE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || '';

// Create Supabase client only if keys exist
export const supabase = SUPABASE_URL && SUPABASE_KEY 
  ? createClient(SUPABASE_URL, SUPABASE_KEY)
  : null;

// Service to fetch data (Hybrid: Supabase -> JSON Fallback)
export const ReconService = {
  async getLatestResults(): Promise<ReconResult> {
    // 1. Try Supabase first (if configured)
    if (supabase) {
      try {
        const { data, error } = await supabase
          .from('recon_scans')
          .select('*')
          .order('created_at', { ascending: false })
          .limit(1)
          .single();

        let detailedArticles: RecoveredArticle[] = [];
        let drafts: DraftArticle[] = [];
        
        // Fetch detailed items from scanned_urls (The Archaeologist's Findings)
        const { data: scanItems } = await supabase
          .from('scanned_urls')
          .select('*')
          .eq('status', 'recuperado') // Only show successful recoveries
          .order('created_at', { ascending: false })
          .limit(20);

        // Fetch Drafts
        const { data: draftItems } = await supabase
          .from('draft_articles')
          .select('*')
          .order('created_at', { ascending: false })
          .limit(10);

        // Fetch total count of recovered items
        const { count } = await supabase
          .from('scanned_urls')
          .select('*', { count: 'exact', head: true })
          .eq('status', 'recuperado');

        if (scanItems) {
            detailedArticles = scanItems.map((item: ScannedUrl) => ({
                url: item.url,
                title: item.title,
                source: item.source
            }));
        }

        if (draftItems) {
            drafts = draftItems.map((item: DraftArticle) => ({
                id: item.id,
                original_url: item.original_url,
                title: item.title,
                status: item.status,
                created_at: item.created_at
            }));
        }

        // We return data even if recon_scans is empty (using current scan items)
        if (scanItems || draftItems) {
             return {
                lastScan: data?.created_at || new Date().toISOString(),
                totalLinks: count || data?.total_links || 0,
                status: data?.status || 'Active (Hunter)',
                recoveredArticles: detailedArticles,
                drafts: drafts
             };
        }
        
        if (data && !error) {
          return {
            lastScan: data.created_at,
            totalLinks: data.total_links,
            status: data.status,
            // Prioritize Real DB findings over the summary JSON if available
            recoveredArticles: detailedArticles.length > 0 ? detailedArticles : data.results_json,
            drafts: drafts
          };
        }
        console.warn('Supabase returned error or no data, falling back to JSON:', error);
      } catch (err) {
        console.warn('Supabase connection failed, falling back to JSON:', err);
      }
    }

    // 2. Fallback to Local JSON (Generated by GitHub Actions)
    try {
      console.log('Fetching local JSON...');
      const response = await fetch('/data/recon_results.json?t=' + Date.now());
      if (!response.ok) throw new Error('Local JSON not found');
      return await response.json();
    } catch (error) {
      console.error('Recon Service Error (JSON):', error);
      // 3. Ultimate Fallback (Empty State)
      return {
        lastScan: new Date().toISOString(),
        totalLinks: 0,
        status: 'Offline / Error',
        recoveredArticles: [],
        drafts: []
      };
    }
  }
};
